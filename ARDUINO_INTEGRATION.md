
# Integrating Arduino (ESP32/ESP8266) with IoT Guardian

This document provides guidance and example code for sending sensor data (like temperature and humidity) from an ESP32 or ESP8266 device to your IoT Guardian Next.js application. The example code provided by the user is for an ESP32 using WiFi and BLE.

## Overview

The process involves your ESP32/ESP8266 device:
1.  Reading data from connected sensors (e.g., DHT11/DHT22 for temperature/humidity, water leak sensors).
2.  Connecting to your network (via Wi-Fi).
3.  Formatting the sensor data into a JSON payload.
4.  Sending this JSON payload as an HTTP POST request to the `/api/sensor-data` endpoint of your Next.js application.

Your Next.js application has an API route (`src/app/api/sensor-data/route.ts`) ready to receive this data.

## Hardware Requirements

*   An ESP32 or ESP8266 board (e.g., NodeMCU, Wemos D1 Mini, ESP32-DevKitC). These have built-in Wi-Fi capabilities.
*   Sensors (e.g., DHT11 or DHT22 for temperature and humidity, water leak sensor).
*   Jumper wires and a breadboard for connections.

## Next.js API Endpoint

Your Next.js application listens for POST requests at:
`/api/sensor-data`

The expected JSON payload format is:
```json
{
  "deviceId": "your_unique_device_id",
  "temperature": 25.5, // Optional, in Celsius
  "humidity": 60.2,   // Optional, in %
  "waterLeak": false, // Optional
  "timestamp": "2023-10-27T10:30:00Z" // Optional, ISO 8601 format (YYYY-MM-DDTHH:mm:ssZ)
}
```
The `deviceId` is crucial for identifying which device sent the data. `timestamp` should ideally be generated by the device at the time of reading, in UTC.

## Example ESP32 Code (User Provided, Adapted)

This example is based on the user's provided code, targeting an ESP32 for sending sensor data via WiFi and potentially interacting via BLE.
**Ensure you have the necessary libraries installed in your Arduino IDE for ESP32:**
*   `WiFi.h` (comes with ESP32 core)
*   `HTTPClient.h` (comes with ESP32 core)
*   `ArduinoJson.h` (by Benoit Blanchon)
*   `BLEDevice.h` (for ESP32 BLE functionality)
*   Any sensor-specific libraries (e.g., `DHT.h` if using DHT sensors directly with ESP32).

If you encounter `HTTPClient.h: No such file or directory`, ensure your Arduino IDE is correctly configured for ESP32 development and the ESP32 board package is installed.

```cpp
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <time.h> // For timestamp

// For BLE (if used, user's code included BLE parts)
// #include <BLEDevice.h>
// #include <BLEUtils.h>
// #include <BLEServer.h>
// #include <BLE2902.h>


// WiFi Credentials
const char* ssid = "YOUR_WIFI_SSID"; // Replace with your WiFi SSID
const char* password = "YOUR_WIFI_PASSWORD"; // Replace with your WiFi Password

// API Endpoint - CRITICAL: Ensure this matches your Next.js app's URL and port
// For local development, use your computer's local IP address where Next.js is running.
// Example: "http://192.168.1.100:9002/api/sensor-data"
// DO NOT use "localhost" or "127.0.0.1" as that refers to the ESP32 itself.
const char* serverUrl = "http://YOUR_NEXTJS_APP_IP_OR_DOMAIN:PORT/api/sensor-data"; 

// Device ID - Make this unique for each device
const char* deviceId = "esp32-prototype-01"; // Example: "esp32-living-room-01"

// Optional: Static IP configuration
// IPAddress local_IP(192, 168, 1, 184);
// IPAddress gateway(192, 168, 1, 1);
// IPAddress subnet(255, 255, 255, 0);

// Communication with another Arduino (if applicable, as per user's code)
// #define ARDUINO_RX 16
// #define ARDUINO_TX 17
// HardwareSerial ArduinoSerial(2); // Using Serial2

unsigned long lastSendTime = 0;
const unsigned long sendInterval = 30000; // Send data every 30 seconds

void connectToWiFi() {
  // Optional: Configure static IP
  // if (!WiFi.config(local_IP, gateway, subnet)) {
  //   Serial.println("STA Failed to configure");
  // }
  
  Serial.print("Connecting to WiFi: ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);

  int attemptCount = 0;
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
    attemptCount++;
    if (attemptCount > 20) { // Timeout after 10 seconds
        Serial.println("\nFailed to connect to WiFi. Please check credentials and network.");
        // ESP.restart(); // Optionally restart
        return; // Or handle error appropriately
    }
  }
  Serial.println("\nWiFi connected!");
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());
}

void configureTime() {
    // Configure time using NTP
    configTime(0, 0, "pool.ntp.org", "time.nist.gov"); // GMT offset, daylight offset, NTP servers
    Serial.print("Waiting for NTP time sync: ");
    time_t now = time(nullptr);
    while (now < 8 * 3600 * 2) { // Check if time is somewhat reasonable (e.g. > 1 Jan 1970)
        delay(500);
        Serial.print(".");
        now = time(nullptr);
    }
    Serial.println("\nTime synchronized");
    struct tm timeinfo;
    gmtime_r(&now, &timeinfo);
    Serial.print("Current time: ");
    Serial.print(asctime(&timeinfo));
}

void sendSensorData(float temp, float hum, bool leakDetected) {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    
    Serial.print("[HTTP] begin...\n");
    // Specify URL. If your server uses HTTPS, you'll need to use WiFiClientSecure.
    if (!http.begin(serverUrl)) { 
      Serial.printf("[HTTP] Unable to connect to %s\n", serverUrl);
      return;
    }

    http.addHeader("Content-Type", "application/json");

    StaticJsonDocument<256> doc; // Adjust size as needed
    doc["deviceId"] = deviceId;
    if (!isnan(temp)) doc["temperature"] = temp;
    if (!isnan(hum)) doc["humidity"] = hum;
    doc["waterLeak"] = leakDetected;

    // Generate timestamp
    time_t now;
    time(&now);
    char timestamp[30];
    // Format as ISO8601 string (YYYY-MM-DDTHH:MM:SSZ)
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%dT%H:%M:%SZ", gmtime(&now));
    doc["timestamp"] = timestamp;
    
    String requestBody;
    serializeJson(doc, requestBody);
    
    Serial.print("[HTTP] POST JSON: ");
    Serial.println(requestBody);

    int httpCode = http.POST(requestBody);

    if (httpCode > 0) {
      Serial.printf("[HTTP] POST... code: %d\n", httpCode);
      if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_CREATED) {
        String payload = http.getString();
        Serial.println("Received response:");
        Serial.println(payload);
      }
    } else {
      Serial.printf("[HTTP] POST... failed, error: %s\n", http.errorToString(httpCode).c_str());
    }

    http.end();
  } else {
    Serial.println("WiFi Disconnected");
    // Attempt to reconnect or handle error
    // connectToWiFi(); 
  }
}

void setup() {
  Serial.begin(115200);
  delay(1000); // Wait for serial monitor to open

  // Connect to WiFi
  connectToWiFi();

  if (WiFi.status() == WL_CONNECTED) {
    // Configure time from NTP server
    configureTime();
  }

  // If communicating with another Arduino via Serial2 (as in user's original full code)
  // ArduinoSerial.begin(9600, SERIAL_8N1, ARDUINO_RX, ARDUINO_TX);

  // Initialize sensors here (e.g., dht.begin())
  
  Serial.println("Setup complete. Device ready.");
}

void loop() {
  unsigned long currentTime = millis();
  if (currentTime - lastSendTime >= sendInterval) {
    lastSendTime = currentTime;

    // --- Read your sensor data here ---
    float temperature = 20.0 + (rand() % 100) / 10.0; // Example: Random temperature
    float humidity = 40.0 + (rand() % 300) / 10.0;    // Example: Random humidity
    bool waterLeak = (rand() % 10) < 2;             // Example: 20% chance of water leak

    // If reading from another Arduino via Serial2:
    /*
    if (ArduinoSerial.available()) {
      String dataFromArduino = ArduinoSerial.readStringUntil('\n');
      dataFromArduino.trim();
      Serial.println("Received from secondary Arduino: " + dataFromArduino);
      // Parse dataFromArduino (e.g., if it's JSON or CSV)
      // And then call sendSensorData(...)
    }
    */
    
    Serial.printf("Sending data: Temp=%.1f, Hum=%.0f, Leak=%s\n", temperature, humidity, waterLeak ? "true" : "false");
    sendSensorData(temperature, humidity, waterLeak);
  }

  // Handle other tasks like BLE if implemented
}
```

**Explanation & Key Changes in Example ESP32 Code:**
*   **`serverUrl`**: Changed to `/api/sensor-data` (you must replace `YOUR_NEXTJS_APP_IP_OR_DOMAIN:PORT` with your actual local IP and Next.js port, e.g., `http://192.168.1.105:9002/api/sensor-data`).
*   **Timestamp**: The code now correctly generates an ISO 8601 timestamp using `time.h` functions after syncing with an NTP server.
*   **WiFi Connection**: Basic connection logic. Static IP configuration is commented out but can be enabled.
*   **Sensor Data**: Placeholder random data is used in `loop()`. You need to replace this with your actual sensor reading logic (e.g., from DHT, analog sensors, or data received from a secondary Arduino via `Serial2` if you are using that setup).
*   **JSON Payload**: Matches the structure expected by the Next.js API.
*   **BLE Code**: Much of the BLE-specific code from your original snippet has been commented out to focus on the WiFi data submission part. If you need BLE, you can integrate those parts back.

**Key Considerations for Arduino/ESP32:**
*   **Local Development URL**: When your Next.js app runs locally (e.g., `http://localhost:9002`), your ESP32 (a separate device on your network) *cannot* use `localhost`. You must use the local IP address of the computer running the Next.js server (e.g., `http://192.168.X.Y:9002/api/sensor-data`). Find your computer's local IP in network settings.
*   **Error Handling**: The example includes basic HTTP error printing. Robust applications need more comprehensive error handling, retry mechanisms, and checks for sensor reading failures.
*   **Power Management**: For battery-powered ESP32 devices, use deep sleep modes to conserve power.
*   **Security**: For production, use HTTPS. ESP32 supports HTTPS (via `WiFiClientSecure.h`), but it requires more setup (e.g., root certificates). Also, consider API keys for your endpoint if exposed to the internet.

By using this setup, your ESP32 should be able to send data to your IoT Guardian application for real-time display.
Remember to replace placeholder values (WiFi credentials, server URL, `deviceId`, and sensor reading logic) in the Arduino code with your actual information.
