
# Integrating Arduino with IoT Guardian

This document provides guidance and example code for sending sensor data (like temperature and humidity) from an Arduino device to your IoT Guardian Next.js application.

## Overview

The process involves your Arduino device:
1.  Reading data from connected sensors (e.g., DHT11/DHT22 for temperature/humidity, water leak sensors).
2.  Connecting to your network (via Wi-Fi using ESP8266/ESP32, or Ethernet shield).
3.  Formatting the sensor data into a JSON payload.
4.  Sending this JSON payload as an HTTP POST request to the `/api/sensor-data` endpoint of your Next.js application.

Your Next.js application already has an API route (`src/app/api/sensor-data/route.ts`) ready to receive this data.

## Hardware Requirements

*   An Arduino board (e.g., Arduino Uno, Nano).
*   A sensor (e.g., DHT11 or DHT22 for temperature and humidity).
*   A way for the Arduino to connect to the internet:
    *   **ESP8266 or ESP32 module/board:** These have built-in Wi-Fi capabilities and can often be programmed directly using the Arduino IDE. This is a common and cost-effective choice.
    *   **Arduino Ethernet Shield:** If you have wired Ethernet access.
*   Jumper wires and a breadboard for connections.

## Next.js API Endpoint

Your Next.js application listens for POST requests at:
`/api/sensor-data`

The expected JSON payload format is:
```json
{
  "deviceId": "your_unique_device_id",
  "temperature": 25.5, // Optional
  "humidity": 60.2,   // Optional
  "waterLeak": false, // Optional
  "timestamp": "2023-10-27T10:30:00Z" // Optional, ISO 8601 format
}
```
The `deviceId` is crucial for identifying which device sent the data. `timestamp` should ideally be generated by the device at the time of reading.

## Example Arduino Code (Using ESP8266 with DHT11/22)

This example demonstrates sending temperature and humidity data from a DHT sensor using an ESP8266 (like NodeMCU or Wemos D1 Mini).

**Libraries Needed (Install via Arduino IDE Library Manager):**
*   `ESP8266WiFi` (usually comes with ESP8266 board support)
*   `ESP8266HTTPClient` (usually comes with ESP8266 board support)
*   `ArduinoJson` (by Benoit Blanchon)
*   `DHT sensor library` (by Adafruit)

```cpp
#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <ArduinoJson.h> // For creating JSON
#include <DHT.h>         // For DHT sensor

// WiFi Credentials
const char* ssid = "YOUR_WIFI_SSID";
const char* password = "YOUR_WIFI_PASSWORD";

// API Endpoint
const char* serverName = "http://YOUR_NEXTJS_APP_URL/api/sensor-data"; // Replace with your app's URL (e.g., http://localhost:3000 for local dev)

// DHT Sensor Setup
#define DHTPIN D2     // What digital pin we're connected to (e.g., D2 on NodeMCU)
#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321. Or use DHT11
DHT dht(DHTPIN, DHTTYPE);

// Device ID - Make this unique for each device
const char* deviceId = "esp8266-living-room-01";

unsigned long lastTime = 0;
unsigned long timerDelay = 30000; // Send data every 30 seconds

void setup() {
  Serial.begin(115200);
  delay(1000);

  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  Serial.println("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());

  dht.begin();
}

void loop() {
  if ((millis() - lastTime) > timerDelay) {
    // Check WiFi connection status
    if (WiFi.status() == WL_CONNECTED) {
      HTTPClient http;
      WiFiClient client; // Declare client here

      // Your Domain name with URL path or IP address with path
      http.begin(client, serverName); // Use the client object
      
      // Specify content-type header
      http.addHeader("Content-Type", "application/json");

      // Prepare JSON document
      StaticJsonDocument<256> doc; // Adjust size as needed
      doc["deviceId"] = deviceId;

      float humidity = dht.readHumidity();
      float temperature = dht.readTemperature(); // Read temperature as Celsius (the default)

      if (isnan(humidity) || isnan(temperature)) {
        Serial.println("Failed to read from DHT sensor!");
      } else {
        doc["temperature"] = temperature;
        doc["humidity"] = humidity;
        // Example: doc["waterLeak"] = digitalRead(WATER_LEAK_PIN_STATUS); // If you have a water leak sensor
      }
      
      // Add timestamp (optional, can also be added by server)
      // For simplicity, we'll let the server handle it if not sent.
      // If you want to send it:
      // time_t now;
      // time(&now);
      // char timestamp[30];
      // strftime(timestamp, sizeof(timestamp), "%Y-%m-%dT%H:%M:%SZ", gmtime(&now));
      // doc["timestamp"] = timestamp;


      // Serialize JSON to string
      String requestBody;
      serializeJson(doc, requestBody);
      Serial.print("Request body: ");
      Serial.println(requestBody);

      // Send HTTP POST request
      int httpResponseCode = http.POST(requestBody);

      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
        
      if (httpResponseCode > 0) {
        String payload = http.getString();
        Serial.println(payload);
      }
      
      // Free resources
      http.end();
    } else {
      Serial.println("WiFi Disconnected. Trying to reconnect...");
      WiFi.begin(ssid, password); // Attempt to reconnect
       while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
      }
    }
    lastTime = millis();
  }
}
```

**Explanation of the Arduino Code:**

1.  **Includes:** Necessary libraries for Wi-Fi, HTTP communication, JSON manipulation, and DHT sensor.
2.  **Credentials & Endpoint:**
    *   `ssid`, `password`: Your Wi-Fi network credentials.
    *   `serverName`: The full URL to your Next.js API endpoint.
        *   For local development, if your Next.js app runs on `http://localhost:9002`, and your Arduino is on the same network, you might use your computer's local IP address (e.g., `http://192.168.1.100:9002/api/sensor-data`) instead of `localhost`. `localhost` on the ESP8266 refers to itself.
3.  **DHT Setup:** Initializes the DHT sensor on the specified pin and type.
4.  **`deviceId`:** A unique identifier for this specific Arduino device.
5.  **`setup()`:**
    *   Initializes Serial communication for debugging.
    *   Connects to your Wi-Fi network.
    *   Initializes the DHT sensor.
6.  **`loop()`:**
    *   **Timer:** Sends data at a regular interval (`timerDelay`).
    *   **Wi-Fi Check:** Ensures Wi-Fi is connected before attempting to send data.
    *   **HTTPClient:**
        *   `http.begin(client, serverName)`: Initializes the HTTP client with the server URL. Using `WiFiClient client;` and passing it to `http.begin()` is recommended for ESP8266.
        *   `http.addHeader("Content-Type", "application/json")`: Sets the request header.
    *   **JSON Creation (`ArduinoJson`):**
        *   A `StaticJsonDocument` is created.
        *   Sensor readings (temperature, humidity) and the `deviceId` are added to the JSON document.
        *   Error handling for DHT sensor reading (`isnan()`).
    *   **Serialization:** `serializeJson(doc, requestBody)` converts the JSON document to a string.
    *   **HTTP POST:** `http.POST(requestBody)` sends the data.
    *   **Response Handling:** Prints the HTTP response code and payload from the server.
    *   **`http.end()`:** Frees up resources.

**Key Considerations for Arduino:**

*   **URL for Local Development:** When your Next.js app is running locally (e.g., `http://localhost:9002`), your Arduino/ESP8266 (which is a separate device on your network) cannot use `localhost`. You need to use the local IP address of the computer running the Next.js server (e.g., `http://192.168.X.Y:9002/api/sensor-data`). You can find your computer's local IP address in your network settings.
*   **Error Handling:** The example includes basic error handling for sensor reading and Wi-Fi connection. Robust applications would require more comprehensive error handling and potentially retry mechanisms.
*   **Power Management:** For battery-powered devices, consider using deep sleep modes to conserve power between transmissions.
*   **Security:** For production, sending data over HTTP is insecure. You should use HTTPS. ESP8266/ESP32 can make HTTPS requests, but it requires more setup (e.g., root certificates). Also, consider API keys or other authentication methods for your API endpoint if it's exposed to the internet.
*   **Data Synchronization:** If precise timing is critical, ensure the Arduino's clock is synchronized (e.g., using NTP) before sending timestamps. Otherwise, let the server add timestamps upon receiving data.

By following this guide, you can configure your Arduino devices to send data to your IoT Guardian application, enabling real-time monitoring and analysis.
